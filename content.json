{"meta":{"title":"Krysia","subtitle":"","description":"","author":"Krysia","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-09-04T01:58:43.000Z","updated":"2021-09-04T01:58:43.958Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Pandas_记录","slug":"Pandas-记录","date":"2021-09-04T00:42:44.000Z","updated":"2021-09-15T12:58:53.843Z","comments":true,"path":"2021/09/04/Pandas-记录/","link":"","permalink":"http://example.com/2021/09/04/Pandas-%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Pandas 常用属性123456pd.DataFramepd.read_csvpd.Seriespd.concatpd.to_datetimepd.merge Pandas Dataframe常用属性1234567891011121314151617181920df.columnsdf.indexdf.to_csvdf.locdf.groupbydf.ser_indexdf.dropdf.ixdf.ilocdf.shapedf.iterrowsdf.sortdf.appenddf.copydf.renamedf.reset_indexdf.applydf.dropnadf.headdf.value 文件读取1234567891011121314df = pd.read_csv(path=&#x27;file.csv&#x27;)参数：header=None 用默认列名，0，1，2，3... names=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;...] 自定义列名 index_col=&#x27;A&#x27;|[&#x27;A&#x27;, &#x27;B&#x27;...] 给索引列指定名称，如果是多重索引，可以传list nrows=N 需要读取的行数，前N行 chunksize=M 返回迭代类型TextFileReader，每M条迭代一次，数据占用较大内存时使用 sep=&#x27;:&#x27;数据分隔默认是&#x27;,&#x27;，根据文件选择合适的分隔符，如果不指定参数，会自动解析 skip_blank_lines=False 默认为True，跳过空行，如果选择不跳过，会填充NaN converters=&#123;&#x27;col1&#x27;, func&#125; 对选定列使用函数func转换，通常表示编号的列会使用（避免转换成int）dfjs = pd.read_json(&#x27;file.json&#x27;) 可以传入json格式字符串dfex = pd.read_excel(&#x27;file.xls&#x27;, sheetname=[0,1..]) 读取多个sheet页，返回多个df的字典 数据筛选12345678910111213141516171819202122232425df.columns 列名，返回Index类型的列的集合df.index 索引名，返回Index类型的索引的集合df.shape 返回tuple，行x列df.head(n=N) 返回前N条df.tail(n=M) 返回后M条df.values 值的二维数组，以numpy.ndarray对象返回df.index DataFrame的索引，索引不可以直接赋值修改df.reindex(index=[&#x27;row1&#x27;, &#x27;row2&#x27;,...]columns=[&#x27;col1&#x27;, &#x27;col2&#x27;,...]) 根据新索引重新排序df[m:n] 切片，选取m~n-1行df[df[&#x27;col1&#x27;] &gt; 1] 选取满足条件的行df.query(&#x27;col1 &gt; 1&#x27;) 选取满足条件的行df.query(&#x27;col1==[v1,v2,...]&#x27;) df.ix[:,&#x27;col1&#x27;] 选取某一列df.ix[&#x27;row1&#x27;, &#x27;col2&#x27;] 选取某一元素df.ix[:,:&#x27;col2&#x27;] 切片选取某一列之前（包括col2）的所有列df.loc[m:n] 获取从m~n行（推荐）df.iloc[m:n] 获取从m~n-1行df.loc[m:n-1,&#x27;col1&#x27;:&#x27;coln&#x27;] 获取从m~n行的col1~coln列sr=df[&#x27;col&#x27;] 取某一列，返回Seriessr.values Series的值，以numpy.ndarray对象返回sr.index Series的索引，以index对象返回 df.sampledf.sample( )用于从dataframe或者series中，随机取样 1234567891011121314151617181920212223DataFrame.sample(self: ~ FrameOrSeries, n=None, #表示从数据集中随机选取n行数据frac=None, #从数据集中选取一定比例的数据 ，与n不连用replace=False, #replace：bool，default False #是否允许重复取样，即一条数据多次选取。默认为否weights=None, # weight：str or narray-like,optional #为每条数据添加权重。默认为None。如果axis = 0，可以直接使用某一列为权重。除非权重的类型为series，否则权重的长度必须和数据集中所用轴方向的（axis=0 or ）一样长。如果权重和大于一，则会归一化为1. # df.sample(3,replace=True,weights=[1,2,3,4])random_state=None, #random_state:int or numpy.random.randomstate.optional 指定随机数种子后，每次选取的结果就固定了随机数种子axis=None#选择轴向，0（index）或者1（columns），默认是0)","categories":[],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]},{"title":"Boring Search","slug":"my-blog","date":"2021-08-30T11:26:00.000Z","updated":"2021-09-03T07:52:11.602Z","comments":true,"path":"2021/08/30/my-blog/","link":"","permalink":"http://example.com/2021/08/30/my-blog/","excerpt":"","text":"torch x = x.view(-1, …)理解在torch里面，view函数相当于numpy的reshape 12345678910111213141516a = torch.arange(1, 17) # a&#x27;s shape is (16,) a.view(4, 4) # output belowtensor([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16]])[torch.FloatTensor of size 4x4] a.view(2, 2, 4) # output belowtensor([[[ 1, 2, 3, 4], [ 5, 6, 7, 8]], [[ 9, 10, 11, 12], [13, 14, 15, 16]]])[torch.FloatTensor of size 2x2x4] 在函数的参数中经常可以看到-1例如x.view(-1, 4) 这里-1表示一个不确定的数，就是你如果不确定你想要reshape成几行，但是你很肯定要reshape成4列，那不确定的地方就可以写成-1 例如一个长度的16向量x， 12x.view(-1, 4)等价于x.view(4, 4)x.view(-1, 2)等价于x.view(8，2)","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}